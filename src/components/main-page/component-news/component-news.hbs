<article class="container-news">
    <div class="image-news"></div>
    <div class="container-information">
        <h2 class="name-information">Information!</h2>
        <div class="text-information">
            <p class="">Sample setup with Gulp, Babel, Mocha and Webpack over ES6, transpiled to ES5 (source maps
                included).

                Skip to main content
                Select language
                Skip to search
                MDN Web Docs
                Technologies References & Guides Feedback
                Sign in
                Search
                Search
                Intersection Observer API
                Languages Edit Advanced
                Jump to: Intersection observer concepts and usageInterfacesA simple exampleSpecificationsBrowser
                compatibilitySee also
                This is an experimental technology
                Check the Browser compatibility table carefully before using this in production.

                The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a
                target element with an ancestor element or with a top-level document's viewport.

                Historically, detecting visibility of an element, or the relative visibility of two elements in relation
                to each other, has been a difficult task for which solutions have been unreliable and prone to causing
                the browser and the sites the user is accessing to become sluggish. Unfortunately, as the web has
                matured, the need for this kind of information has grown. Intersection information is needed for many
                reasons, such as:

                Lazy-loading of images or other content as a page is scrolled.
                Implementing "infinite scrolling" web sites, where more and more content is loaded and rendered as you
                scroll, so that the user doesn't have to flip through pages.
                Reporting of visibility of advertisements in order to calculate ad revenues.
                Deciding whether or not to perform tasks or animation processes based on whether or not the user will
                see the result.
                Implementing intersection detection in the past involved event handlers and loops calling methods like
                Element.getBoundingClientRect() to build up the needed information for every element affected. Since all
                this code runs on the main thread, even one of these can cause performance problems. When a site is
                loaded with these tests, things can get downright ugly.

                Consider a web page that uses infinite scrolling. It uses a vendor-provided library to manage the
                advertisements placed periodically throughout the page, has animated graphics here and there, and uses a
                custom library that draws notification boxes and the like. Each of these has its own intersection
                detection routines, all running on the main thread. The author of the web site may not even realize this
                is happening, since they're using two libraries that they may know very little about the inner workings
                of. As the user scrolls the page, these intersection detection routines are firing constantly during the
                scroll handling code, resulting in an experience that leaves the user frustrated with the browser, the
                web site, and their computer.

                The Intersection Observer API lets code register a callback function that is executed whenever an
                element they wish to monitor enters or exits another element (or the viewport), or when the amount by
                which the two intersect changes by a requested amount. This way, sites no longer need to do anything on
                the main thread to watch for this kind of element intersection, and the browser is free to optimize the
                management of intersections as it sees fit.

                One thing the Intersection Observer API can't tell you: the exact number of pixels that overlap or
                specifically which ones they are; however, it covers the much more common use case of "If they intersect
                by somewhere around N%, I need to do something."

                Intersection observer concepts and usageSection
                The Intersection Observer API allows you to configure a callback that is called whenever one element,
                called the target, intersects either the device viewport or a specified element; for the purpose of this
                API, this is called the root element or root. Typically, you'll want to watch for intersection changes
                with regard to the document's viewport (which is done by specifying null as the root element ). Whether
                you're using the viewport or some other element as the root, the API works the same way, executing a
                callback function you provide whenever the visibility of the target element changes so that it crosses
                desired amounts of intersection with the root.

                The degree of intersection between the target element and its root is the intersection ratio. This is a
                representation of the percentage of the target element which is visible as a value between 0.0 and 1.0.

                Creating an intersection observerSection
                Create the intersection observer by calling its constructor and passing it a callback function to be run
                whenever a threshold is crossed in one direction or the other:

                var options = {
                root: document.querySelector('#scrollArea'),
                rootMargin: '0px',
                threshold: 1.0
                }

                var observer = new IntersectionObserver(callback, options);
                A threshold of 1.0 means that when 100% of the target is visible within the element specified by the
                root option, the callback is invoked.

                Intersection observer options
                The options object passed into the IntersectionObserver() constructor let you control the circumstances
                under which the observer's callback is invoked. It has the following fields:

                root
                The element that is used as the viewport for checking visiblity of the target. Must be the ancestor of
                the target. Defaults to the browser viewport if not specified or if null.
                rootMargin
                Margin around the root. Can have values similar to the CSS margin property, e.g. "10px 20px 30px 40px"
                (top, right, bottom, left). The values can be percentages. This set of values serves to grow or shrink
                each side of the root element's bounding box before computing intersections. Defaults to all zeros.
                threshold
                Either a single number or an array of numbers which indicate at what percentage of the target's
                visibility the observer's callback should be executed. If you only want to detect when visibility passes
                the 50% mark, you can use a value of 0.5. If you want the callback run every time visibility passes
                another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1]. The default is 0 (meaning as soon as
                even one pixel is visible, the callback will be run). A value of 1.0 means that the threshold isn't
                considered passed until every pixel is visible.
                Targeting an element to be observed
                Once you have created the observer, you need to give it a target element to watch:

                var target = document.querySelector('#listItem');
                observer.observe(target);
                Whenever the target meets a threshold specified for the IntersectionObserver, the callback is invoked.
                The callback receives a list of IntersectionObserverEntry objects and the observer:

                var callback = function(entries, observer) {
                entries.forEach(entry => {
                // Each entry describes an intersection change for one observed
                // target element:
                // entry.boundingClientRect
                // entry.intersectionRatio
                // entry.intersectionRect
                // entry.isIntersecting
                // entry.rootBounds
                // entry.target
                // entry.time
                });
                };
                Be aware that your callback is executed on the main thread. It should operate as quickly as possible; if
                anything time-consuming needs to be done, use Window.requestIdleCallback().

                Also, note that if you specified the root option, the target must be a descendant of the root element.

                How intersection is calculatedSection
                All areas considered by the Intersection Observer API are rectangles; elements which are irregularly
                shaped are considered as occupying the smallest rectangle which encloses all of the element's parts.
                Similarly, if the visible portion of an element is not rectangular, the element's intersection rectangle
                is construed to be the smallest rectangle that contains all the visible portions of the element.

                It's useful to understand a bit about how the various properties provided by IntersectionObserverEntry
                describe an intersection.

                The intersection root and root margin
                Before we can track the intersection of an element with a container, we need to know what that container
                is. That container is the intersection root, or root element. This can be either an element in the
                document which is an ancestor of the element to be observed, or null to use the document's viewport as
                the container.

                The rectangle used as the bounds of the intersection root can be adjusted by setting the root margin,
                rootMargin, when creating the IntersectionObserver. The values in rootMargin define offsets added to
                each side of the intersection root's bounding box to create the final intersection root bounds (which
                are disclosed in IntersectionObserverEntry.rootBounds when the callback is executed).

                Thresholds
                Rather than reporting every infinitesimal change in how much a target element is visible, the
                Intersection Observer API uses thresholds. When you create an observer, you can provide one or more
                numeric values representing percentages of the target element which are visible. Then, the API only
                reports changes to visibility which cross these thresholds.

                For example, if you want to be informed every time a target's visibility passes backward or forward
                through each 25% mark, you would specify the array [0, 0.25, 0.5, 0.75, 1] as the list of thresholds
                when creating the observer. You can tell which direction the visibility changed in (that is, whether the
                element became more visible or less visible) by checking the value of the isIntersecting property on the
                IntersectionObserverEntry passed into the callback function at the time of the visibility change. If
                isIntersecting is true, the target element has become at least as visible as the threshold that was
                passed. If it's false, the target is no longer as visible as the given threshold.

                To get a feeling for how thresholds work, try scrolling the box below around. Each colored box within it
                displays the percentage of itself that's visible in all four of its corners, so you can see these ratios
                change over time as you scroll the container. Each box has a different set of thresholds:

                The first box has a threshold for each percentage point of visibility; that is, the
                IntersectionObserver.thresholds array is [0.00, 0.01, 0.02, ..., 0.99, 1.00].
                The second box has a single threshold, at the 50% mark.
                The third box has thresholds every 10% of visibility (0%, 10%, 20%, etc.).
                The last box has thresholds each 25%.

                Open in CodePen Open in JSFiddle

                Intersection change callbacksSection
                When the amount of a target element which is visible within the root element crosses one of the
                visibility thresholds,

                InterfacesSection
                IntersectionObserver
                The primary interface for the Intersection Observer API. Provides methods for creating and managing an
                observer which can watch any number of target elements for the same intersection configuration. Each
                observer can asynchronously observe changes in the intersection between one or more target elements and
                a shared ancestor element or with their top-level Document's viewport. The ancestor or viewport is
                referred to as the root.
                IntersectionObserverEntry
                Describes the intersection between the target element and its root container at a specific moment of
                transition. Objects of this type can only be obtained in two ways: as an input to your
                IntersectionObserver callback, or by calling IntersectionObserver.takeRecords().
                A simple exampleSection
                This simple example causes a target element to change its color and transparency as it becomes more or
                less visible. At Timing element visibility with the Intersection Observer API, you can find a more
                extensive example showing how to time how long a set of elements (such as ads) are visible to the user
                and to react to that information by recording statistics or by updating elements..

                HTMLSection
                The HTML for this example is very short, with a primary element which is the box that we'll be targeting
                (with the creative ID "box") and some contents within the box.

                © 2005-2018 Mozilla and individual contributors. Content is available under these licenses.
            </p>
        </div>
    </div>
    <a href="news-page.html" class="text-information-more link-a">Read more...</a>
</article>